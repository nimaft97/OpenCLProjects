#define LOCAL_DATA_ARRAY_LENGTH 1024
#define MAX_WORK_GROUP_SIZE 512
#define NUM_BUCKETS 10  // one bucket for each digit (0, 1, 2, ..., 9)

__kernel void radixSort(__global int* data, const int n, const int max_digit) 
{
    // global_size = local_size
    // Work-group size
    const int global_size = get_global_size(0);
    const int global_id = get_global_id(0);

    // Check if the global_id is within the range of the array
    if (global_id >= n)
    {
        return;
    }

    // Define and populate local memory
    // it is assumed that LOCAL_DATA_ARRAY_LENGTH >= n and n is a power of two
    __local int local_data[2][LOCAL_DATA_ARRAY_LENGTH];
    // shared memory initialized to zero so that each thread can write to isolated elements
    // it then will be used as an input to prefix-sum (once for each bucket)
    __local int local_partial_freq[NUM_BUCKETS][MAX_WORK_GROUP_SIZE];
    for (int i = global_id; i < n; i += global_size)
    {
        // create two copies of global memory
        local_data[0][i] = data[i];
        local_data[1][i] = data[i];
    }

    // number of threads that contribute
    const int num_active_threads = min(n, global_size);
    // number of consecutive elements that each thread must cover
    // note that these are stored in the register of each thread
    int num_elements_to_cover = n / num_active_threads;
    if (global_id < (n % num_active_threads))
    {
        // some threads need to cover more elements in the local array
        // because n is not always divisible by num_active_threads
        // n = 10, num_active_threads = 7 -> 2 2 2 1 1 1 1
        num_elements_to_cover++;
    }
    // index of the local array that this thread starts at
    const int index_to_start = global_id * (n / num_active_threads) + min(n % num_active_threads, global_id);
    // Synchronize before proceeding
    barrier(CLK_LOCAL_MEM_FENCE);

    for (int digit_idx = 0; digit_idx < max_digit; ++digit_idx)
    {

        // reset local_partial_freq
        for (int i = 0; i < NUM_BUCKETS; ++i)
        {
            local_partial_freq[i][global_id] = 0;
        }
        // sync
        barrier(CLK_LOCAL_MEM_FENCE);

        // which instance of local_data has valid data
        const int valid_copy_idx = digit_idx % 2;

        // count and update bucket array (buckket_arr[#buckets][#threads])
        for (int idx = index_to_start; idx < index_to_start + num_elements_to_cover; ++idx)
        {
            const int bucket = local_data[valid_copy_idx][idx] % 10;
            local_partial_freq[bucket][global_id]++;
        }

        // sync
        barrier(CLK_LOCAL_MEM_FENCE);

        for (int bucket_idx = 0; bucket_idx < NUM_BUCKETS; ++bucket_idx)
        {
            // prefix-sum for each bucket on local_partial_freq
            // ???????????
        }

        // sync before taking care of the next digit
        barrier(CLK_LOCAL_MEM_FENCE);
    }
    // prefix sum #bucket times
    // populate the second local array, place numbers in order
    // repeat until all digits are considered

    // Update the global memory with the valid copy of local memory
    for (int i = global_id; i < n; i += global_size)
    {
        data[i] = local_data[i];
    }
}
